<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MRVL Frontend Comprehensive Test Suite</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #4f9cf9;
            margin-bottom: 30px;
            font-size: 2.5rem;
        }
        .test-section {
            background: rgba(255,255,255,0.1);
            margin: 20px 0;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #4f9cf9;
        }
        .test-button {
            background: linear-gradient(45deg, #4f9cf9, #6366f1);
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 10px 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        .test-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        .results {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .success { color: #10b981; }
        .error { color: #ef4444; }
        .warning { color: #f59e0b; }
        .info { color: #3b82f6; }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4f9cf9, #10b981);
            width: 0%;
            transition: width 0.5s ease;
        }
        .summary {
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid #10b981;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        iframe {
            width: 100%;
            height: 400px;
            border: 2px solid #4f9cf9;
            border-radius: 8px;
            background: white;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-online { background: #10b981; }
        .status-offline { background: #ef4444; }
        .status-warning { background: #f59e0b; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ MRVL Frontend Comprehensive Test Suite</h1>
        
        <div class="test-section">
            <h2>üìä Real-time Test Dashboard</h2>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>
            <div id="overallStatus">
                <span class="status-indicator status-warning"></span>
                <span>Initializing tests...</span>
            </div>
        </div>

        <div class="grid">
            <!-- Page Navigation Tests -->
            <div class="test-section">
                <h3>üîó Page Navigation Tests</h3>
                <button class="test-button" onclick="testPageNavigation()">Test All Pages</button>
                <button class="test-button" onclick="testSpecificPage('/matches')">Test Matches</button>
                <button class="test-button" onclick="testSpecificPage('/admin')">Test Admin</button>
                <div class="results" id="navigationResults"></div>
            </div>

            <!-- Live Scoring Tests -->
            <div class="test-section">
                <h3>‚ö° Live Scoring Tests</h3>
                <button class="test-button" onclick="testLiveScoring()">Test Live Features</button>
                <button class="test-button" onclick="testRealTimeSync()">Test Real-time Sync</button>
                <button class="test-button" onclick="testMatchControl()">Test Match Control</button>
                <div class="results" id="liveScoringResults"></div>
            </div>

            <!-- API Connectivity Tests -->
            <div class="test-section">
                <h3>üåê API Connectivity Tests</h3>
                <button class="test-button" onclick="testAPIEndpoints()">Test API Endpoints</button>
                <button class="test-button" onclick="testWebSocket()">Test WebSocket</button>
                <button class="test-button" onclick="testDataFlow()">Test Data Flow</button>
                <div class="results" id="apiResults"></div>
            </div>

            <!-- Performance Tests -->
            <div class="test-section">
                <h3>‚ö° Performance Tests</h3>
                <button class="test-button" onclick="testLoadTimes()">Test Load Times</button>
                <button class="test-button" onclick="testResponsive()">Test Responsive</button>
                <button class="test-button" onclick="testMemoryUsage()">Test Memory</button>
                <div class="results" id="performanceResults"></div>
            </div>
        </div>

        <!-- Live Preview Section -->
        <div class="test-section">
            <h3>üëÅÔ∏è Live Preview & Testing</h3>
            <div class="grid">
                <div>
                    <h4>Main App</h4>
                    <iframe id="mainFrame" src="http://localhost:3000"></iframe>
                </div>
                <div>
                    <h4>Admin Dashboard</h4>
                    <iframe id="adminFrame" src="http://localhost:3000/admin"></iframe>
                </div>
            </div>
        </div>

        <!-- Test Results Summary -->
        <div class="test-section">
            <h3>üìã Comprehensive Test Actions</h3>
            <button class="test-button" onclick="runAllTests()" style="font-size: 16px; padding: 15px 30px;">
                üöÄ Run All Tests
            </button>
            <button class="test-button" onclick="testConcurrentUpdates()">Test Concurrent Updates</button>
            <button class="test-button" onclick="testErrorHandling()">Test Error Handling</button>
            <button class="test-button" onclick="simulateMatchUpdates()">Simulate Live Match</button>
            <button class="test-button" onclick="downloadResults()">Download Results</button>
        </div>

        <div class="results" id="allResults"></div>
        
        <div class="summary" id="testSummary" style="display: none;">
            <h3>üìä Test Summary</h3>
            <div id="summaryContent"></div>
        </div>
    </div>

    <script>
        // Test state management
        let testResults = {
            navigation: {},
            liveScoring: {},
            api: {},
            performance: {},
            issues: [],
            summary: {}
        };

        let totalTests = 0;
        let completedTests = 0;

        // Utility functions
        function log(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            const className = type;
            element.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
            element.scrollTop = element.scrollHeight;
        }

        function updateProgress() {
            const percentage = totalTests > 0 ? (completedTests / totalTests) * 100 : 0;
            document.getElementById('progressBar').style.width = percentage + '%';
            
            if (percentage === 100) {
                updateOverallStatus('success', 'All tests completed');
            }
        }

        function updateOverallStatus(status, message) {
            const statusElement = document.getElementById('overallStatus');
            const statusClass = status === 'success' ? 'status-online' : 
                               status === 'error' ? 'status-offline' : 'status-warning';
            statusElement.innerHTML = `<span class="status-indicator ${statusClass}"></span><span>${message}</span>`;
        }

        // Page Navigation Tests
        async function testPageNavigation() {
            log('navigationResults', 'üîç Testing page navigation...', 'info');
            totalTests += 6;
            
            const pages = [
                { name: 'Home', url: '/' },
                { name: 'Matches', url: '/matches' },
                { name: 'Teams', url: '/teams' },
                { name: 'Players', url: '/players' },
                { name: 'Rankings', url: '/rankings' },
                { name: 'Admin', url: '/admin' }
            ];

            for (const page of pages) {
                try {
                    const startTime = Date.now();
                    const response = await fetch(`http://localhost:3000${page.url}`);
                    const loadTime = Date.now() - startTime;
                    
                    if (response.ok) {
                        log('navigationResults', `‚úÖ ${page.name}: ${response.status} (${loadTime}ms)`, 'success');
                        testResults.navigation[page.name] = { status: 'success', loadTime, statusCode: response.status };
                    } else {
                        log('navigationResults', `‚ùå ${page.name}: ${response.status}`, 'error');
                        testResults.navigation[page.name] = { status: 'error', statusCode: response.status };
                        testResults.issues.push(`${page.name} page returned ${response.status}`);
                    }
                } catch (error) {
                    log('navigationResults', `‚ùå ${page.name}: ${error.message}`, 'error');
                    testResults.navigation[page.name] = { status: 'error', error: error.message };
                    testResults.issues.push(`${page.name} page failed: ${error.message}`);
                }
                completedTests++;
                updateProgress();
            }
        }

        async function testSpecificPage(path) {
            log('navigationResults', `üîç Testing ${path}...`, 'info');
            
            try {
                const startTime = Date.now();
                const response = await fetch(`http://localhost:3000${path}`);
                const loadTime = Date.now() - startTime;
                const text = await response.text();
                
                const hasReactRoot = text.includes('id="root"');
                const hasTitle = /<title>([^<]*)<\/title>/.test(text);
                
                log('navigationResults', `‚úÖ ${path}: ${response.status} (${loadTime}ms)`, 'success');
                log('navigationResults', `   React Root: ${hasReactRoot ? '‚úÖ' : '‚ùå'}`, hasReactRoot ? 'success' : 'error');
                log('navigationResults', `   Has Title: ${hasTitle ? '‚úÖ' : '‚ùå'}`, hasTitle ? 'success' : 'error');
                
            } catch (error) {
                log('navigationResults', `‚ùå ${path}: ${error.message}`, 'error');
            }
        }

        // Live Scoring Tests
        async function testLiveScoring() {
            log('liveScoringResults', '‚ö° Testing live scoring features...', 'info');
            
            // Test localStorage functionality
            try {
                const testKey = 'mrvl-test-' + Date.now();
                const testData = { score: 100, timestamp: Date.now() };
                
                localStorage.setItem(testKey, JSON.stringify(testData));
                const retrieved = JSON.parse(localStorage.getItem(testKey));
                localStorage.removeItem(testKey);
                
                if (retrieved && retrieved.score === 100) {
                    log('liveScoringResults', '‚úÖ localStorage functionality working', 'success');
                    testResults.liveScoring.localStorage = true;
                } else {
                    log('liveScoringResults', '‚ùå localStorage test failed', 'error');
                    testResults.liveScoring.localStorage = false;
                }
            } catch (error) {
                log('liveScoringResults', `‚ùå localStorage error: ${error.message}`, 'error');
                testResults.liveScoring.localStorage = false;
            }

            // Test WebSocket support
            if (window.WebSocket) {
                log('liveScoringResults', '‚úÖ WebSocket supported in browser', 'success');
                testResults.liveScoring.webSocketSupport = true;
            } else {
                log('liveScoringResults', '‚ùå WebSocket not supported', 'error');
                testResults.liveScoring.webSocketSupport = false;
            }

            // Test EventSource (SSE) support
            if (window.EventSource) {
                log('liveScoringResults', '‚úÖ Server-Sent Events supported', 'success');
                testResults.liveScoring.sseSupport = true;
            } else {
                log('liveScoringResults', '‚ùå Server-Sent Events not supported', 'error');
                testResults.liveScoring.sseSupport = false;
            }
        }

        async function testRealTimeSync() {
            log('liveScoringResults', 'üîÑ Testing real-time synchronization...', 'info');
            
            // Test cross-tab communication via localStorage
            const testChannel = 'mrvl-sync-test-' + Date.now();
            let messageReceived = false;

            const handleStorageChange = (event) => {
                if (event.key === testChannel) {
                    messageReceived = true;
                    log('liveScoringResults', '‚úÖ Cross-tab localStorage sync working', 'success');
                    window.removeEventListener('storage', handleStorageChange);
                }
            };

            window.addEventListener('storage', handleStorageChange);
            
            // Simulate cross-tab update
            setTimeout(() => {
                localStorage.setItem(testChannel, JSON.stringify({
                    type: 'score_update',
                    data: { team1: 1, team2: 0 },
                    timestamp: Date.now()
                }));
                
                setTimeout(() => {
                    localStorage.removeItem(testChannel);
                    if (!messageReceived) {
                        log('liveScoringResults', '‚ö†Ô∏è Cross-tab sync test inconclusive (single tab)', 'warning');
                    }
                    window.removeEventListener('storage', handleStorageChange);
                }, 1000);
            }, 500);

            testResults.liveScoring.crossTabSync = true;
        }

        async function testMatchControl() {
            log('liveScoringResults', 'üéÆ Testing match control features...', 'info');
            
            // Test if we can access admin features
            try {
                const response = await fetch('http://localhost:3000/admin');
                if (response.ok) {
                    log('liveScoringResults', '‚úÖ Admin dashboard accessible', 'success');
                    testResults.liveScoring.adminAccess = true;
                } else {
                    log('liveScoringResults', '‚ùå Admin dashboard not accessible', 'error');
                    testResults.liveScoring.adminAccess = false;
                }
            } catch (error) {
                log('liveScoringResults', `‚ùå Admin access error: ${error.message}`, 'error');
                testResults.liveScoring.adminAccess = false;
            }
        }

        // API Tests
        async function testAPIEndpoints() {
            log('apiResults', 'üåê Testing API endpoints...', 'info');
            
            const endpoints = [
                '/api/matches',
                '/api/teams', 
                '/api/players',
                '/api/events',
                '/api/rankings'
            ];

            const backendUrl = 'http://localhost:8000';

            for (const endpoint of endpoints) {
                try {
                    const response = await fetch(`${backendUrl}${endpoint}`);
                    if (response.ok) {
                        const data = await response.json();
                        log('apiResults', `‚úÖ ${endpoint}: ${response.status} (${Array.isArray(data) ? data.length : 'N/A'} items)`, 'success');
                        testResults.api[endpoint] = { status: 'success', statusCode: response.status, dataLength: Array.isArray(data) ? data.length : 0 };
                    } else {
                        log('apiResults', `‚ùå ${endpoint}: ${response.status}`, 'error');
                        testResults.api[endpoint] = { status: 'error', statusCode: response.status };
                    }
                } catch (error) {
                    log('apiResults', `‚ùå ${endpoint}: ${error.message}`, 'error');
                    testResults.api[endpoint] = { status: 'error', error: error.message };
                    testResults.issues.push(`API ${endpoint} failed: ${error.message}`);
                }
            }
        }

        async function testWebSocket() {
            log('apiResults', 'üîå Testing WebSocket connectivity...', 'info');
            
            // Test if we can create a WebSocket connection
            try {
                const ws = new WebSocket('ws://localhost:6001');
                
                ws.onopen = () => {
                    log('apiResults', '‚úÖ WebSocket connection established', 'success');
                    testResults.api.webSocket = { status: 'success', connected: true };
                    ws.close();
                };
                
                ws.onerror = (error) => {
                    log('apiResults', '‚ùå WebSocket connection failed', 'error');
                    testResults.api.webSocket = { status: 'error', connected: false };
                };
                
                ws.onclose = () => {
                    log('apiResults', '‚ÑπÔ∏è WebSocket connection closed', 'info');
                };
                
                // Timeout after 5 seconds
                setTimeout(() => {
                    if (ws.readyState === WebSocket.CONNECTING) {
                        log('apiResults', '‚ö†Ô∏è WebSocket connection timeout', 'warning');
                        testResults.api.webSocket = { status: 'timeout', connected: false };
                        ws.close();
                    }
                }, 5000);
                
            } catch (error) {
                log('apiResults', `‚ùå WebSocket error: ${error.message}`, 'error');
                testResults.api.webSocket = { status: 'error', error: error.message };
            }
        }

        async function testDataFlow() {
            log('apiResults', 'üîÑ Testing data flow...', 'info');
            
            // Test CORS
            try {
                const response = await fetch('http://localhost:8000/api/matches', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    log('apiResults', '‚úÖ CORS configured correctly', 'success');
                    testResults.api.cors = true;
                } else {
                    log('apiResults', '‚ùå CORS issues detected', 'error');
                    testResults.api.cors = false;
                }
            } catch (error) {
                if (error.message.includes('CORS')) {
                    log('apiResults', '‚ùå CORS blocking requests', 'error');
                    testResults.api.cors = false;
                } else {
                    log('apiResults', `‚ÑπÔ∏è Network error (expected if backend offline): ${error.message}`, 'info');
                    testResults.api.cors = 'unknown';
                }
            }
        }

        // Performance Tests
        async function testLoadTimes() {
            log('performanceResults', '‚ö° Testing load times...', 'info');
            
            const pages = ['/', '/matches', '/teams', '/admin'];
            
            for (const page of pages) {
                try {
                    const startTime = performance.now();
                    const response = await fetch(`http://localhost:3000${page}`);
                    const endTime = performance.now();
                    const loadTime = Math.round(endTime - startTime);
                    
                    if (response.ok) {
                        const status = loadTime < 1000 ? 'success' : loadTime < 3000 ? 'warning' : 'error';
                        const emoji = loadTime < 1000 ? 'üöÄ' : loadTime < 3000 ? '‚ö†Ô∏è' : 'üêå';
                        log('performanceResults', `${emoji} ${page}: ${loadTime}ms`, status);
                        
                        testResults.performance[page] = { loadTime, status: response.status };
                    }
                } catch (error) {
                    log('performanceResults', `‚ùå ${page}: ${error.message}`, 'error');
                }
            }
        }

        async function testResponsive() {
            log('performanceResults', 'üì± Testing responsive design features...', 'info');
            
            // Test viewport meta tag
            const viewportMeta = document.querySelector('meta[name="viewport"]');
            if (viewportMeta) {
                log('performanceResults', '‚úÖ Viewport meta tag found', 'success');
                testResults.performance.viewport = true;
            } else {
                log('performanceResults', '‚ùå Viewport meta tag missing', 'error');
                testResults.performance.viewport = false;
            }
            
            // Test CSS media queries support
            if (window.matchMedia) {
                log('performanceResults', '‚úÖ CSS Media Queries supported', 'success');
                testResults.performance.mediaQueries = true;
                
                // Test specific breakpoints
                const breakpoints = {
                    mobile: '(max-width: 768px)',
                    tablet: '(max-width: 1024px)',
                    desktop: '(min-width: 1025px)'
                };
                
                for (const [name, query] of Object.entries(breakpoints)) {
                    const mq = window.matchMedia(query);
                    log('performanceResults', `üì± ${name} breakpoint: ${mq.matches ? 'active' : 'inactive'}`, 'info');
                }
            } else {
                log('performanceResults', '‚ùå Media Queries not supported', 'error');
                testResults.performance.mediaQueries = false;
            }
        }

        async function testMemoryUsage() {
            log('performanceResults', 'üß† Testing memory usage...', 'info');
            
            if (performance.memory) {
                const memory = performance.memory;
                const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                const totalMB = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                
                log('performanceResults', `üß† Memory: ${usedMB}MB used / ${totalMB}MB total (limit: ${limitMB}MB)`, 'info');
                
                const memoryUsagePercent = (usedMB / limitMB) * 100;
                if (memoryUsagePercent < 50) {
                    log('performanceResults', '‚úÖ Memory usage is good', 'success');
                } else if (memoryUsagePercent < 80) {
                    log('performanceResults', '‚ö†Ô∏è Memory usage is moderate', 'warning');
                } else {
                    log('performanceResults', '‚ùå High memory usage detected', 'error');
                }
                
                testResults.performance.memory = { used: usedMB, total: totalMB, limit: limitMB, percent: memoryUsagePercent };
            } else {
                log('performanceResults', '‚ÑπÔ∏è Memory API not available', 'info');
                testResults.performance.memory = null;
            }
        }

        // Advanced Tests
        async function testConcurrentUpdates() {
            log('allResults', 'üîÑ Testing concurrent updates...', 'info');
            
            // Simulate multiple rapid localStorage updates
            const promises = [];
            for (let i = 0; i < 10; i++) {
                promises.push(new Promise(resolve => {
                    setTimeout(() => {
                        const key = `test-concurrent-${i}`;
                        const data = { update: i, timestamp: Date.now() };
                        localStorage.setItem(key, JSON.stringify(data));
                        
                        // Verify the update
                        const retrieved = JSON.parse(localStorage.getItem(key));
                        localStorage.removeItem(key);
                        
                        resolve(retrieved.update === i);
                    }, i * 10);
                }));
            }
            
            const results = await Promise.all(promises);
            const successful = results.filter(r => r).length;
            
            log('allResults', `‚úÖ Concurrent updates: ${successful}/10 successful`, 'success');
            testResults.summary.concurrentUpdates = { successful, total: 10 };
        }

        async function testErrorHandling() {
            log('allResults', 'üö® Testing error handling...', 'info');
            
            // Test 404 page
            try {
                const response = await fetch('http://localhost:3000/non-existent-page');
                log('allResults', `404 Page: ${response.status}`, response.status === 404 ? 'success' : 'warning');
                testResults.summary.errorHandling = { 
                    has404: response.status === 404 
                };
            } catch (error) {
                log('allResults', `Error handling test failed: ${error.message}`, 'error');
            }
            
            // Test invalid API call
            try {
                await fetch('http://localhost:8000/api/invalid-endpoint');
                log('allResults', '‚ÑπÔ∏è Invalid API endpoint tested', 'info');
            } catch (error) {
                log('allResults', '‚ÑπÔ∏è Network error handling works', 'info');
            }
        }

        async function simulateMatchUpdates() {
            log('allResults', 'üéÆ Simulating live match updates...', 'info');
            
            const updates = [
                { type: 'score_update', data: { team1: 1, team2: 0 } },
                { type: 'player_stats', data: { playerId: 1, kills: 5, deaths: 2 } },
                { type: 'hero_change', data: { playerId: 1, hero: 'Spider-Man' } },
                { type: 'map_complete', data: { winner: 'team1', map: 'King\'s Row' } }
            ];
            
            for (let i = 0; i < updates.length; i++) {
                setTimeout(() => {
                    const update = updates[i];
                    const key = `mrvl-live-update-${Date.now()}`;
                    localStorage.setItem(key, JSON.stringify({
                        ...update,
                        timestamp: Date.now()
                    }));
                    
                    log('allResults', `üì§ Simulated: ${update.type}`, 'info');
                    
                    // Clean up after 1 second
                    setTimeout(() => localStorage.removeItem(key), 1000);
                }, i * 500);
            }
            
            testResults.summary.matchSimulation = { updatesSimulated: updates.length };
        }

        // Main test runner
        async function runAllTests() {
            log('allResults', 'üöÄ Starting comprehensive test suite...', 'info');
            updateOverallStatus('warning', 'Running tests...');
            
            totalTests = 20; // Estimate
            completedTests = 0;
            
            // Reset results
            testResults = {
                navigation: {},
                liveScoring: {},
                api: {},
                performance: {},
                issues: [],
                summary: {}
            };
            
            // Run all tests
            await testPageNavigation();
            await testLiveScoring();
            await testRealTimeSync();
            await testMatchControl();
            await testAPIEndpoints();
            await testWebSocket();
            await testDataFlow();
            await testLoadTimes();
            await testResponsive();
            await testMemoryUsage();
            await testConcurrentUpdates();
            await testErrorHandling();
            await simulateMatchUpdates();
            
            // Generate summary
            generateTestSummary();
            
            log('allResults', 'üéâ All tests completed!', 'success');
            updateOverallStatus('success', 'All tests completed successfully');
        }

        function generateTestSummary() {
            const summary = document.getElementById('testSummary');
            const content = document.getElementById('summaryContent');
            
            const navigationPassed = Object.values(testResults.navigation).filter(r => r.status === 'success').length;
            const navigationTotal = Object.keys(testResults.navigation).length;
            
            const apiPassed = Object.values(testResults.api).filter(r => r.status === 'success').length;
            const apiTotal = Object.keys(testResults.api).length;
            
            const performanceGood = Object.values(testResults.performance).filter(r => 
                typeof r === 'object' && (r.loadTime < 3000 || r === true)
            ).length;
            
            content.innerHTML = `
                <div class="grid">
                    <div>
                        <h4>üìä Test Results</h4>
                        <p><strong>Navigation:</strong> ${navigationPassed}/${navigationTotal} passed</p>
                        <p><strong>API Endpoints:</strong> ${apiPassed}/${apiTotal} working</p>
                        <p><strong>Live Scoring:</strong> ${testResults.liveScoring.localStorage ? '‚úÖ' : '‚ùå'} localStorage</p>
                        <p><strong>Real-time:</strong> ${testResults.liveScoring.webSocketSupport ? '‚úÖ' : '‚ùå'} WebSocket support</p>
                        <p><strong>Performance:</strong> ${performanceGood} metrics good</p>
                    </div>
                    <div>
                        <h4>üîß Technical Details</h4>
                        <p><strong>Frontend:</strong> ${navigationTotal > 0 ? '‚úÖ' : '‚ùå'} Accessible</p>
                        <p><strong>CORS:</strong> ${testResults.api.cors === true ? '‚úÖ' : testResults.api.cors === false ? '‚ùå' : '‚ö†Ô∏è'} ${testResults.api.cors}</p>
                        <p><strong>WebSocket:</strong> ${testResults.api.webSocket?.connected ? '‚úÖ' : '‚ùå'} ${testResults.api.webSocket?.status || 'Not tested'}</p>
                        <p><strong>Memory:</strong> ${testResults.performance.memory ? testResults.performance.memory.percent.toFixed(1) + '%' : 'N/A'}</p>
                        <p><strong>Issues:</strong> ${testResults.issues.length} found</p>
                    </div>
                </div>
                
                ${testResults.issues.length > 0 ? `
                <h4>‚ö†Ô∏è Issues Found</h4>
                <ul>
                    ${testResults.issues.map(issue => `<li>${issue}</li>`).join('')}
                </ul>
                ` : '<p class="success">üéâ No issues found!</p>'}
            `;
            
            summary.style.display = 'block';
        }

        function downloadResults() {
            const results = {
                timestamp: new Date().toISOString(),
                testResults,
                userAgent: navigator.userAgent,
                viewport: {
                    width: window.innerWidth,
                    height: window.innerHeight
                }
            };
            
            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `mrvl-frontend-test-results-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log('allResults', 'üìÅ Results downloaded', 'success');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('allResults', 'üéÆ MRVL Frontend Test Suite loaded', 'success');
            updateOverallStatus('online', 'Ready to run tests');
            
            // Auto-refresh iframes every 30 seconds
            setInterval(() => {
                try {
                    document.getElementById('mainFrame').src = document.getElementById('mainFrame').src;
                    document.getElementById('adminFrame').src = document.getElementById('adminFrame').src;
                } catch (error) {
                    // Ignore iframe errors
                }
            }, 30000);
        });
    </script>
</body>
</html>