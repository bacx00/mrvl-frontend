{"version":3,"file":"static/js/127.2ad99ce5.chunk.js","mappings":"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","sources":["services/liveUpdateService.js"],"sourcesContent":["/**\n * Live Update Service - Professional Real-Time Connection Manager\n * \n * Provides bulletproof WebSocket/SSE connections with:\n * - Automatic reconnection with exponential backoff\n * - Connection health monitoring\n * - Multiple transport fallbacks (WebSocket -> SSE -> Polling)\n * - Sub-second latency optimizations\n * - Memory leak prevention\n * - Error recovery and logging\n */\n\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'https://staging.mrvl.net';\n\n// Connection states\nconst CONNECTION_STATES = {\n  DISCONNECTED: 'disconnected',\n  CONNECTING: 'connecting', \n  CONNECTED: 'connected',\n  RECONNECTING: 'reconnecting',\n  FAILED: 'failed'\n};\n\n// Transport types\nconst TRANSPORT_TYPES = {\n  WEBSOCKET: 'websocket',\n  SSE: 'sse', \n  POLLING: 'polling'\n};\n\nclass LiveUpdateService {\n  constructor() {\n    this.connections = new Map();\n    this.subscribers = new Map();\n    this.reconnectAttempts = new Map();\n    this.maxReconnectAttempts = 10;\n    this.baseReconnectDelay = 1000; // Start with 1 second\n    this.maxReconnectDelay = 30000; // Max 30 seconds\n    this.heartbeatInterval = 25000; // 25 seconds\n    this.connectionTimeout = 15000; // 15 seconds\n    \n    // Bind methods to maintain context\n    this.handleVisibilityChange = this.handleVisibilityChange.bind(this);\n    this.handleOnline = this.handleOnline.bind(this);\n    this.handleOffline = this.handleOffline.bind(this);\n    \n    // Setup global event listeners\n    this.setupGlobalListeners();\n    \n    console.log('🚀 LiveUpdateService initialized - Professional real-time connections ready');\n  }\n\n  /**\n   * Setup global event listeners for connection management\n   */\n  setupGlobalListeners() {\n    if (typeof window !== 'undefined') {\n      // Handle page visibility changes\n      document.addEventListener('visibilitychange', this.handleVisibilityChange);\n      \n      // Handle network status changes\n      window.addEventListener('online', this.handleOnline);\n      window.addEventListener('offline', this.handleOffline);\n      \n      // Handle page unload\n      window.addEventListener('beforeunload', () => {\n        this.disconnectAll();\n      });\n    }\n  }\n\n  /**\n   * Connect to live updates for a specific match with automatic transport selection\n   * @param {number} matchId - Match ID to connect to\n   * @param {Function} onUpdate - Callback for receiving updates\n   * @param {Object} options - Connection options\n   */\n  async connectToMatch(matchId, onUpdate, options = {}) {\n    const connectionKey = `match_${matchId}`;\n    \n    if (this.connections.has(connectionKey)) {\n      console.log(`⚡ Already connected to match ${matchId}`);\n      this.addSubscriber(connectionKey, onUpdate);\n      return;\n    }\n\n    const connection = {\n      matchId,\n      connectionKey,\n      state: CONNECTION_STATES.CONNECTING,\n      transport: null,\n      lastUpdate: Date.now(),\n      options: {\n        preferredTransport: options.transport || TRANSPORT_TYPES.SSE,\n        enableHeartbeat: options.heartbeat !== false,\n        enableReconnect: options.reconnect !== false,\n        ...options\n      },\n      healthCheck: {\n        lastPing: 0,\n        lastPong: 0,\n        missedHeartbeats: 0\n      }\n    };\n\n    this.connections.set(connectionKey, connection);\n    this.addSubscriber(connectionKey, onUpdate);\n    \n    try {\n      await this.establishConnection(connection);\n    } catch (error) {\n      console.error(`❌ Failed to connect to match ${matchId}:`, error);\n      this.handleConnectionError(connection, error);\n    }\n  }\n\n  /**\n   * Establish connection using the best available transport\n   */\n  async establishConnection(connection) {\n    const { matchId, options } = connection;\n    \n    // Try transports in order of preference: SSE -> WebSocket -> Polling\n    const transportPriority = [\n      TRANSPORT_TYPES.SSE,\n      TRANSPORT_TYPES.WEBSOCKET,\n      TRANSPORT_TYPES.POLLING\n    ];\n\n    for (const transport of transportPriority) {\n      if (options.preferredTransport && options.preferredTransport !== transport && transportPriority.indexOf(options.preferredTransport) < transportPriority.indexOf(transport)) {\n        continue;\n      }\n\n      try {\n        console.log(`🔌 Attempting ${transport.toUpperCase()} connection for match ${matchId}`);\n        \n        switch (transport) {\n          case TRANSPORT_TYPES.SSE:\n            await this.connectSSE(connection);\n            break;\n          case TRANSPORT_TYPES.WEBSOCKET:\n            await this.connectWebSocket(connection);\n            break;\n          case TRANSPORT_TYPES.POLLING:\n            await this.connectPolling(connection);\n            break;\n        }\n        \n        connection.transport = transport;\n        connection.state = CONNECTION_STATES.CONNECTED;\n        console.log(`✅ Successfully connected to match ${matchId} via ${transport.toUpperCase()}`);\n        \n        // Reset reconnect attempts on successful connection\n        this.reconnectAttempts.set(connection.connectionKey, 0);\n        \n        // Start heartbeat monitoring\n        if (options.enableHeartbeat) {\n          this.startHeartbeat(connection);\n        }\n        \n        return; // Success, exit loop\n        \n      } catch (error) {\n        console.error(`❌ ${transport.toUpperCase()} connection failed for match ${matchId}:`, error);\n        this.closeConnection(connection, false);\n      }\n    }\n    \n    throw new Error(`All transport methods failed for match ${matchId}`);\n  }\n\n  /**\n   * Connect using Server-Sent Events (SSE)\n   */\n  async connectSSE(connection) {\n    return new Promise((resolve, reject) => {\n      const { matchId, options } = connection;\n      const url = `${BACKEND_URL}/api/live-updates/stream/${matchId}`;\n      \n      const eventSource = new EventSource(url, {\n        withCredentials: true\n      });\n\n      let connectionTimeout = setTimeout(() => {\n        reject(new Error('SSE connection timeout'));\n      }, this.connectionTimeout);\n\n      eventSource.onopen = () => {\n        clearTimeout(connectionTimeout);\n        console.log(`📡 SSE connection established for match ${matchId}`);\n        resolve();\n      };\n\n      eventSource.onmessage = (event) => {\n        this.handleMessage(connection, event.data);\n      };\n\n      // Handle specific event types from backend\n      const eventTypes = ['score-update', 'hero-update', 'stats-update', 'map-update', 'status-update', 'connected'];\n      eventTypes.forEach(eventType => {\n        eventSource.addEventListener(eventType, (event) => {\n          this.handleMessage(connection, event.data, eventType);\n        });\n      });\n\n      eventSource.onerror = (error) => {\n        clearTimeout(connectionTimeout);\n        console.error(`❌ SSE error for match ${matchId}:`, error);\n        reject(error);\n      };\n\n      connection.transport_connection = eventSource;\n    });\n  }\n\n  /**\n   * Connect using WebSocket (fallback)\n   */\n  async connectWebSocket(connection) {\n    return new Promise((resolve, reject) => {\n      const { matchId } = connection;\n      \n      // WebSocket URL would need to be implemented on backend\n      const wsUrl = `${BACKEND_URL.replace('http', 'ws')}/ws/match/${matchId}`;\n      \n      const ws = new WebSocket(wsUrl);\n      \n      let connectionTimeout = setTimeout(() => {\n        reject(new Error('WebSocket connection timeout'));\n      }, this.connectionTimeout);\n\n      ws.onopen = () => {\n        clearTimeout(connectionTimeout);\n        console.log(`🔌 WebSocket connection established for match ${matchId}`);\n        \n        // Send initial subscription message\n        ws.send(JSON.stringify({\n          type: 'subscribe',\n          match_id: matchId,\n          channels: ['scores', 'heroes', 'stats']\n        }));\n        \n        resolve();\n      };\n\n      ws.onmessage = (event) => {\n        this.handleMessage(connection, event.data);\n      };\n\n      ws.onerror = (error) => {\n        clearTimeout(connectionTimeout);\n        console.error(`❌ WebSocket error for match ${matchId}:`, error);\n        reject(error);\n      };\n\n      ws.onclose = (event) => {\n        if (connection.state === CONNECTION_STATES.CONNECTED) {\n          console.log(`🔌 WebSocket closed for match ${matchId}, attempting reconnect`);\n          this.scheduleReconnect(connection);\n        }\n      };\n\n      connection.transport_connection = ws;\n    });\n  }\n\n  /**\n   * Connect using polling (last resort)\n   */\n  async connectPolling(connection) {\n    const { matchId } = connection;\n    \n    console.log(`⏰ Starting polling connection for match ${matchId}`);\n    \n    const pollInterval = setInterval(async () => {\n      if (connection.state === CONNECTION_STATES.DISCONNECTED) {\n        clearInterval(pollInterval);\n        return;\n      }\n\n      try {\n        const response = await fetch(`${BACKEND_URL}/api/live-updates/status/${matchId}`, {\n          method: 'GET',\n          headers: {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n          },\n          signal: AbortSignal.timeout(5000)\n        });\n\n        if (response.ok) {\n          const data = await response.json();\n          this.handleMessage(connection, JSON.stringify(data));\n        }\n      } catch (error) {\n        console.error(`❌ Polling error for match ${matchId}:`, error);\n        this.handleConnectionError(connection, error);\n      }\n    }, 1000); // Poll every second\n\n    connection.transport_connection = pollInterval;\n    connection.state = CONNECTION_STATES.CONNECTED;\n    \n    return Promise.resolve();\n  }\n\n  /**\n   * Handle incoming messages from any transport\n   */\n  handleMessage(connection, data, eventType = null) {\n    try {\n      connection.lastUpdate = Date.now();\n      connection.healthCheck.lastPong = Date.now();\n      \n      let parsedData;\n      if (typeof data === 'string') {\n        // Handle heartbeat messages\n        if (data.trim() === '' || data.startsWith(':')) {\n          return; // Ignore heartbeat/comment messages\n        }\n        \n        parsedData = JSON.parse(data);\n      } else {\n        parsedData = data;\n      }\n\n      // Handle connection confirmation\n      if (parsedData.status === 'connected') {\n        console.log(`✅ Connection confirmed for match ${connection.matchId}`);\n        return;\n      }\n\n      // Enhance data with metadata\n      const enhancedData = {\n        ...parsedData,\n        matchId: connection.matchId,\n        timestamp: Date.now(),\n        transport: connection.transport,\n        eventType: eventType || parsedData.type || 'update'\n      };\n\n      // Notify all subscribers\n      this.notifySubscribers(connection.connectionKey, enhancedData);\n      \n    } catch (error) {\n      console.error('❌ Error handling message:', error, data);\n    }\n  }\n\n  /**\n   * Add subscriber to connection\n   */\n  addSubscriber(connectionKey, callback) {\n    if (!this.subscribers.has(connectionKey)) {\n      this.subscribers.set(connectionKey, new Set());\n    }\n    this.subscribers.get(connectionKey).add(callback);\n  }\n\n  /**\n   * Remove subscriber from connection\n   */\n  removeSubscriber(connectionKey, callback) {\n    const subs = this.subscribers.get(connectionKey);\n    if (subs) {\n      subs.delete(callback);\n      if (subs.size === 0) {\n        this.subscribers.delete(connectionKey);\n        // Close connection if no subscribers\n        const connection = this.connections.get(connectionKey);\n        if (connection) {\n          this.closeConnection(connection);\n        }\n      }\n    }\n  }\n\n  /**\n   * Notify all subscribers of an update\n   */\n  notifySubscribers(connectionKey, data) {\n    const subs = this.subscribers.get(connectionKey);\n    if (subs) {\n      subs.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('❌ Error in subscriber callback:', error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Start heartbeat monitoring for connection health\n   */\n  startHeartbeat(connection) {\n    if (connection.heartbeatTimer) {\n      clearInterval(connection.heartbeatTimer);\n    }\n\n    connection.heartbeatTimer = setInterval(() => {\n      const now = Date.now();\n      const timeSinceLastUpdate = now - connection.lastUpdate;\n      \n      // If no update received in too long, consider connection dead\n      if (timeSinceLastUpdate > this.heartbeatInterval * 2) {\n        console.log(`💔 Heartbeat timeout for match ${connection.matchId}, reconnecting`);\n        connection.healthCheck.missedHeartbeats++;\n        \n        if (connection.healthCheck.missedHeartbeats >= 3) {\n          this.scheduleReconnect(connection);\n        }\n      }\n\n      // Send ping for WebSocket connections\n      if (connection.transport === TRANSPORT_TYPES.WEBSOCKET && connection.transport_connection.readyState === WebSocket.OPEN) {\n        connection.transport_connection.send(JSON.stringify({ type: 'ping' }));\n        connection.healthCheck.lastPing = now;\n      }\n    }, this.heartbeatInterval);\n  }\n\n  /**\n   * Schedule reconnection with exponential backoff\n   */\n  scheduleReconnect(connection) {\n    if (!connection.options.enableReconnect || connection.state === CONNECTION_STATES.RECONNECTING) {\n      return;\n    }\n\n    const attempts = this.reconnectAttempts.get(connection.connectionKey) || 0;\n    \n    if (attempts >= this.maxReconnectAttempts) {\n      console.error(`❌ Max reconnection attempts reached for match ${connection.matchId}`);\n      connection.state = CONNECTION_STATES.FAILED;\n      this.notifySubscribers(connection.connectionKey, {\n        type: 'connection_failed',\n        matchId: connection.matchId,\n        message: 'Maximum reconnection attempts exceeded'\n      });\n      return;\n    }\n\n    connection.state = CONNECTION_STATES.RECONNECTING;\n    this.reconnectAttempts.set(connection.connectionKey, attempts + 1);\n\n    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, 30s (capped)\n    const delay = Math.min(this.baseReconnectDelay * Math.pow(2, attempts), this.maxReconnectDelay);\n    \n    console.log(`🔄 Scheduling reconnect for match ${connection.matchId} in ${delay}ms (attempt ${attempts + 1})`);\n    \n    setTimeout(async () => {\n      try {\n        // Close existing connection first\n        this.closeConnection(connection, false);\n        \n        // Attempt to re-establish connection\n        await this.establishConnection(connection);\n        \n      } catch (error) {\n        console.error(`❌ Reconnection failed for match ${connection.matchId}:`, error);\n        this.scheduleReconnect(connection); // Try again\n      }\n    }, delay);\n  }\n\n  /**\n   * Handle connection errors\n   */\n  handleConnectionError(connection, error) {\n    console.error(`❌ Connection error for match ${connection.matchId}:`, error);\n    \n    connection.state = CONNECTION_STATES.FAILED;\n    \n    this.notifySubscribers(connection.connectionKey, {\n      type: 'connection_error',\n      matchId: connection.matchId,\n      error: error.message,\n      timestamp: Date.now()\n    });\n\n    // Attempt reconnection if enabled\n    if (connection.options.enableReconnect) {\n      this.scheduleReconnect(connection);\n    }\n  }\n\n  /**\n   * Close a specific connection\n   */\n  closeConnection(connection, removeFromMap = true) {\n    if (connection.heartbeatTimer) {\n      clearInterval(connection.heartbeatTimer);\n      connection.heartbeatTimer = null;\n    }\n\n    if (connection.transport_connection) {\n      try {\n        switch (connection.transport) {\n          case TRANSPORT_TYPES.SSE:\n            connection.transport_connection.close();\n            break;\n          case TRANSPORT_TYPES.WEBSOCKET:\n            connection.transport_connection.close();\n            break;\n          case TRANSPORT_TYPES.POLLING:\n            clearInterval(connection.transport_connection);\n            break;\n        }\n      } catch (error) {\n        console.error('Error closing transport connection:', error);\n      }\n      connection.transport_connection = null;\n    }\n\n    connection.state = CONNECTION_STATES.DISCONNECTED;\n\n    if (removeFromMap) {\n      this.connections.delete(connection.connectionKey);\n      this.subscribers.delete(connection.connectionKey);\n      this.reconnectAttempts.delete(connection.connectionKey);\n    }\n  }\n\n  /**\n   * Disconnect from match updates\n   */\n  disconnectFromMatch(matchId, callback = null) {\n    const connectionKey = `match_${matchId}`;\n    \n    if (callback) {\n      this.removeSubscriber(connectionKey, callback);\n    } else {\n      // Remove all subscribers and close connection\n      const connection = this.connections.get(connectionKey);\n      if (connection) {\n        this.closeConnection(connection);\n      }\n    }\n  }\n\n  /**\n   * Disconnect all connections\n   */\n  disconnectAll() {\n    console.log('🔌 Disconnecting all live update connections');\n    \n    this.connections.forEach(connection => {\n      this.closeConnection(connection, false);\n    });\n    \n    this.connections.clear();\n    this.subscribers.clear();\n    this.reconnectAttempts.clear();\n  }\n\n  /**\n   * Handle page visibility changes\n   */\n  handleVisibilityChange() {\n    if (document.hidden) {\n      // Page hidden - reduce update frequency or pause connections\n      console.log('📱 Page hidden - reducing update frequency');\n    } else {\n      // Page visible - resume normal operation and force refresh\n      console.log('📱 Page visible - resuming normal updates');\n      this.connections.forEach(connection => {\n        if (connection.state === CONNECTION_STATES.FAILED) {\n          this.scheduleReconnect(connection);\n        }\n      });\n    }\n  }\n\n  /**\n   * Handle online/offline status\n   */\n  handleOnline() {\n    console.log('🌐 Network back online - attempting to reconnect');\n    this.connections.forEach(connection => {\n      if (connection.state === CONNECTION_STATES.FAILED) {\n        this.scheduleReconnect(connection);\n      }\n    });\n  }\n\n  handleOffline() {\n    console.log('🌐 Network offline - connections will attempt to reconnect when online');\n  }\n\n  /**\n   * Get connection status for a match\n   */\n  getConnectionStatus(matchId) {\n    const connectionKey = `match_${matchId}`;\n    const connection = this.connections.get(connectionKey);\n    \n    if (!connection) {\n      return { status: CONNECTION_STATES.DISCONNECTED };\n    }\n\n    return {\n      status: connection.state,\n      transport: connection.transport,\n      lastUpdate: connection.lastUpdate,\n      reconnectAttempts: this.reconnectAttempts.get(connectionKey) || 0,\n      healthCheck: connection.healthCheck\n    };\n  }\n\n  /**\n   * Force reconnection for a match\n   */\n  forceReconnect(matchId) {\n    const connectionKey = `match_${matchId}`;\n    const connection = this.connections.get(connectionKey);\n    \n    if (connection) {\n      console.log(`🔄 Forcing reconnection for match ${matchId}`);\n      this.scheduleReconnect(connection);\n    }\n  }\n\n  /**\n   * Get debug information\n   */\n  getDebugInfo() {\n    const connectionInfo = {};\n    this.connections.forEach((connection, key) => {\n      connectionInfo[key] = {\n        state: connection.state,\n        transport: connection.transport,\n        lastUpdate: connection.lastUpdate,\n        reconnectAttempts: this.reconnectAttempts.get(key) || 0,\n        subscriberCount: this.subscribers.get(key)?.size || 0\n      };\n    });\n\n    return {\n      totalConnections: this.connections.size,\n      connections: connectionInfo,\n      totalSubscribers: Array.from(this.subscribers.values()).reduce((sum, subs) => sum + subs.size, 0)\n    };\n  }\n\n  /**\n   * Cleanup on service destruction\n   */\n  cleanup() {\n    this.disconnectAll();\n    \n    if (typeof window !== 'undefined') {\n      document.removeEventListener('visibilitychange', this.handleVisibilityChange);\n      window.removeEventListener('online', this.handleOnline);\n      window.removeEventListener('offline', this.handleOffline);\n    }\n    \n    console.log('🧹 LiveUpdateService cleaned up');\n  }\n}\n\n// Create singleton instance\nconst liveUpdateService = new LiveUpdateService();\n\n// Export both instance and class\nexport default liveUpdateService;\nexport { LiveUpdateService, CONNECTION_STATES, TRANSPORT_TYPES };\n\n// For debugging in browser console\nif (typeof window !== 'undefined') {\n  window.liveUpdateService = liveUpdateService;\n}"],"names":["BACKEND_URL","process","CONNECTION_STATES","TRANSPORT_TYPES","liveUpdateService","constructor","this","connections","Map","subscribers","reconnectAttempts","maxReconnectAttempts","baseReconnectDelay","maxReconnectDelay","heartbeatInterval","connectionTimeout","handleVisibilityChange","bind","handleOnline","handleOffline","setupGlobalListeners","console","log","window","document","addEventListener","disconnectAll","connectToMatch","matchId","onUpdate","options","arguments","length","undefined","connectionKey","concat","has","addSubscriber","connection","state","transport","lastUpdate","Date","now","_objectSpread","preferredTransport","enableHeartbeat","heartbeat","enableReconnect","reconnect","healthCheck","lastPing","lastPong","missedHeartbeats","set","establishConnection","error","handleConnectionError","transportPriority","indexOf","toUpperCase","connectSSE","connectWebSocket","connectPolling","startHeartbeat","closeConnection","Error","Promise","resolve","reject","url","eventSource","EventSource","withCredentials","setTimeout","onopen","clearTimeout","onmessage","event","handleMessage","data","forEach","eventType","onerror","transport_connection","wsUrl","replace","ws","WebSocket","send","JSON","stringify","type","match_id","channels","onclose","scheduleReconnect","pollInterval","setInterval","async","response","fetch","method","headers","signal","AbortSignal","timeout","ok","json","clearInterval","parsedData","trim","startsWith","parse","status","enhancedData","timestamp","notifySubscribers","callback","Set","get","add","removeSubscriber","subs","delete","size","heartbeatTimer","readyState","OPEN","attempts","message","delay","Math","min","pow","removeFromMap","close","disconnectFromMatch","clear","hidden","getConnectionStatus","forceReconnect","getDebugInfo","connectionInfo","key","_this$subscribers$get","subscriberCount","totalConnections","totalSubscribers","Array","from","values","reduce","sum","cleanup","removeEventListener"],"sourceRoot":""}